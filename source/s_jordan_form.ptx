<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="s_jordan_form" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Jordan form</title>

    <definition xml:id="d_jordan_block">
        <title>Jordan block</title>

        <statement>
            <p>
                Let <m>F</m> be a field.
                Given <m>\lambda\in F</m> and positive integer <m>k</m>, the <m>k\times k</m> matrix
                <me>
                    J=\begin{bmatrix} \lambda \amp 1\amp 0 \amp \dots \amp 0\\ 0 \amp \lambda\amp 1 \amp \\ \vdots \amp  \amp \ddots \amp \ddots \\ \amp \amp \amp \amp 1\\ 0\amp \dots \amp \amp \amp \lambda \end{bmatrix}
                </me>
                is called a <term><m>\lambda</m>-Jordan block</term>.
            </p>
        </statement>
    </definition>

    <definition xml:id="d_jordan_basis">
        <title>Jordan basis</title>

        <statement>
            <p>
                Let <m>T\in \mathcal{L}(V)</m>, where <m>V</m> is finite dimensional.
                A <term>Jordan basis</term> of <m>T</m> is a basis <m>B</m> for which <m>A=[T]_{B}</m> is block diagonal of the form
                <me>
                    A=\begin{bmatrix}J_{1}\amp \\ \amp J_{2}\amp \\ \amp \amp \ddots \\ \amp \amp \amp J_{r} \end{bmatrix}
                </me>
                where each <m>J_{i}</m> is a <m>\lambda_i</m>-Jordan block for some <m>\lambda_i\in F</m>.
                The matrix <m>A</m> is called a <term>Jordan form</term> of <m>T</m> in this case.
            </p>
        </statement>
    </definition>

    <definition xml:id="d_cycle_gen_eigenvectors">
        <title>Cycle of generalized eigenvectors</title>

        <statement>
            <p>
                Let <m>T\in \mathcal{L}(V)</m> where <m>V</m> is finite dimensional, and let <m>\lambda</m> be an eigenvalue of <m>T</m>.
                A <term>cycle of generalized eigenvectors</term> of <m>T</m> corresponding to <m>\lambda</m> is a tuple of the form
                <me>
                    \left((T-\lambda I)^{k-1}(\boldv), (T-\lambda I)^{k-2}(\boldv), \dots, (T-\lambda I)(\boldv), \boldv\right)
                </me>
                where <m>\boldv\ne \boldzero</m> and <m>k</m> is the smallest positive integer satisfying <m>(T-\lambda I)^{k}(\boldv)=\boldzero</m>.
                The vector <m>(T-\lambda I)^{k-1}(\boldv)</m> is called the <term>initial vector</term> of the cycle; the vector <m>\boldv</m> is called the <term>end vector</term> of the cycle.
            </p>
        </statement>
    </definition>

    <theorem xml:id="th_jordan_cycles">
        <title>Jordan blocks</title>

        <statement>
            <p>
                Let <m>T\in \mathcal{L}(V)</m> where <m>V</m> is finite dimensional.
                <ol>
                    <li>
                        <m>[T]_{B}</m> is a Jordan block if and only if <m>B</m> is a cycle of generalized eigenvectors.
                    </li>

                    <li>
                        <m>[T]_{B}</m> is a Jordan form if and only if <m>B</m> is a concatenation <m>B=B_1*B_2*\cdots * B_r</m> of disjoint cycles of generalized eigenvectors.
                    </li>

                    <li>
                        A cycle of generalized eigenvectors is linearly independent, and its initial vector is an eigenvector.
                    </li>

                    <li>
                        If <m>B_1, B_2, \dots, B_\ell</m> are cycles of generalized eigenvectors corresponding to a fixed <m>\lambda</m> whose initial vectors are linearly independent, then the concatenation <m>B_1*B_2*\cdots * B_\ell</m> is linearly independent.
                    </li>
                </ol>
            </p>
        </statement>


        <proof>
            <p>
            </p>
        </proof>
    </theorem>

    <theorem xml:id="th_jordan_form">
        <title>Jordan form</title>

        <statement>
            <p>
                    Let <m>T\in \mathcal{L}(V)</m> where <m>V</m> is finite dimensional, and suppose all roots of the characteristic polynomial of <m>T</m> lie in <m>\F</m>.
                    <ol>
                        <li>
                            There is a Jordan basis <m>B</m> for <m>T</m>.
                        </li>

                        <li>
                            The corresponding Jordan form 
                            <me> 
                                A=[T]_B=\begin{bmatrix} J_1\amp \\ \amp J_2\amp \\ \amp    \amp\ddots \\ \amp     \amp     \amp J_r \end{bmatrix}
                            </me> is unique up to a permutation of the Jordan blocks <m>J_{i}</m>.
                        </li>
                    </ol>
            </p>
        </statement>


        <proof>
            <p>
            </p>
        </proof>
    </theorem>
<definition xml:id="d_Jordan_form">
<title>Jordan form</title>
<statement>
<p>
Let <m>T,S\in \mathcal{L}(V)</m>, where <m>V</m> is finite dimensional. Assume that the characteristic polynomials of <m>T</m> and <m>S</m> both split completely over the base field. We say <m>T</m> and <m>S</m> have the <term>same Jordan form</term> if they have Jordan forms that differ by a permutation of the Jordan blocks. 
</p>
</statement>
</definition>

   

    <algorithm xml:id="proc_dot_diagram">
        <title>Dot diagram</title>
        <statement>
            <p>
              Let <m>T\in \mathcal{L}(V)</m>, where <m>V</m> is finite dimensional.
Fix an eigenvalue <m>\lambda</m>, and let <m>B=B_{1}*B_{2}*\dots * B_{r}</m> be a Jordan basis of <m>G(\lambda, T)</m>, where each <m>B_{j}</m> is a cycle of generalized <m>\lambda</m>-eigenvectors satisfying <m>\len B_j\geq \len B_{j+1}</m> for all <m>1\leq j\leq r-1</m>.
The <term>dot diagram</term> of <m>B</m> is an staircase pattern of dots constructed in the manner described below. 

For all <m>i\geq 1</m>, let <m>r_{i}</m> be the number of dots in the <m>i</m>-th row of the dot diagram.
<ul>
    <li>
        <p>
           Dots are placed into a rectangular grid containing <m>\len B_1</m> rows and <m>r</m> columns. For all <m>1\leq i\leq p</m>, the <m>i</m>-th row contains <m>r_{i}</m> dots, and these are placed consecutively starting in the leftmost column.  
        </p>
    </li>
    <li>
        <p>
            We have 
            <me>
                r_i=\dim \NS(T-\lambda I)^{i}-\dim\NS(T-\lambda I)^{i-1}.
            </me>
            for all <m>1\leq i</m>. 
        </p>
    </li>
</ul>
The dot diagram is interpreted as follows. 
<ul>
    <li>
        <p>
            For any <m>k\geq 1</m>, the total number of dots in the first <m>i</m> rows of the diagram is equal to <m>\dim \NS (T-\lambda I)^{k}</m>: <ie/>, 
            <me>
                \dim \NS (T-\lambda I)^k=\sum_{i=1}^kr_i
            </me>.
            In particular, we have 
            <me>
                r=r_1=\dim \NS(T-\lambda I)
            </me>.
            Thus the number of <m>\lambda</m>-Jordan blocks of <m>T</m> is equal to the number of dots in the first row of the diagram, which is equal to  <m>\dim \NS(T-\lambda I)</m>.
        </p>
    </li>
    <li>
        <p>
            For each <m>1\leq j\leq r</m>, the number of dots <m>c_j</m> in the <m>j</m>-th column of the diagram is equal to the length of <m>B_j</m>. Equivalently, <m>c_j</m> is the size of the <m>j</m>-th <m>\lambda</m>-Jordan block. 
        </p>
    </li>
    

    
</ul>
            </p>
        </statement>
    </algorithm>
<p>
We illustrate how to compute a normal form for a matrix transformation <m>T_A\colon F^n\rightarrow F^n</m> in <xref first="eg_jordan_form_1" last="eg_jordan_form"/>. Since those examples take up quite a lot of space, we place them at the end of the section. In the meantime, we list some interesting theoretical consequences of <xref ref="th_jordan_form"/>.  

</p>
     <theorem xml:id="th_similarity">
        <title>Similarity</title>
        <statement>
            <p>
               Let <m>A, A'\in \F^{n,n}</m> and suppose both characteristic polynomials factor completely over <m>\F</m>.
The following statements are equivalent.
<ol>
    <li>
        <p>
            <m>A</m> and <m>A'</m> are similar (i.e. <m>A'=P^{-1}AP</m> for some invertible <m>P</m>).
        </p>
    </li>

    <li>
        <p>
            <m>A</m> and <m>A'</m> have the same Jordan form.
        </p>
    </li>
</ol>
            </p>
        </statement>
    </theorem>
    <theorem xml:id="th_diagable_plus_nilpotent">
    <title>Diagonal plus nilpotent</title>
    <statement>
    <p>
    Let <m>T\in \mathcal{L}(V)</m>, where <m>V</m> is finite-dimensional, and assume the characteristic polynomial of <m>T</m> splits completely over the base field. There are operators <m>S,N\in \mathcal{L}(V)</m> satisfying the following conditions: 
    <ul>
        <li>
            <p>
                <m>T=S+N</m>;
            </p>
        </li>
        <li>
            <p>
                <m>S</m> is diagonalizable; 
            </p>
        </li>
        <li>
            <p>
                <m>N</m> is nilpotent (<ie/>, <m>N^k=0_V</m> for some <m>k\in \Z_+</m>).
            </p>
        </li>
    </ul>
    In other words <m>T</m> is the sum of a diagonalizable and a nilpotent operator. 
    </p>
    </statement>
    <proof>
    <p>
    </p>
    </proof>
    </theorem>
    
    <theorem xml:id="th_square_roots">
    <title>Square-roots of complex matrices</title>
    <statement>
    <p>
    Let <m>A\in \C^{n,n}</m> be an invertible matrix. There is a matrix <m>B</m> such that <m>B^2=A</m>. In other words, every invertible complex matrix has a square root. 
    </p>
    </statement>
    <proof>
    <p>
    </p>
    </proof>
    </theorem>
<p>
    In order to illustrate the subtleties of the Jordan form analysis, we need to work with larger matrices than usual, and this in turn compels us to reach for some computing technology. The wonderful open source computer algebra system Sage serves our needs for this task. 
</p>
<example xml:id="eg_jordan_form_1">
<title>Computing Jordan form</title>
<statement>
<p>
Consider the matrix transformation <m>T=T_A\colon \R^8\rightarrow \R^8</m>, where 
<me>
    A=\begin{amatrix}[rrrrrrrr]
3 \amp 2 \amp 3 \amp 2 \amp 3 \amp -1 \amp -3 \amp -3 \\
-5 \amp -4 \amp -13 \amp -15 \amp -15 \amp 2 \amp 16 \amp 1 \\
-1 \amp -1 \amp -5 \amp -7 \amp -6 \amp 1 \amp 7 \amp -2 \\
-1 \amp -2 \amp 7 \amp 23 \amp 11 \amp -5 \amp -20 \amp 21 \\
0 \amp 0 \amp 2 \amp -7 \amp -1 \amp 1 \amp 7 \amp -8 \\
1 \amp 1 \amp 3 \amp 1 \amp 2 \amp 0 \amp -1 \amp -2 \\
-2 \amp -3 \amp 2 \amp 7 \amp 2 \amp -3 \amp -4 \amp 11 \\
-1 \amp -1 \amp -5 \amp -14 \amp -9 \amp 2 \amp 14 \amp -8
    \end{amatrix}
</me>.
Compute the characteristic polynomial <m>f</m> of <m>A</m>. 
</p>
<sage>
    <input>
        A=matrix([(3, 2, 3, 2, 3, -1, -3, -3), (-5, -4, -13, -15, -15, 2, 16, 1), (-1, -1, -5, -7, -6, 1, 7, -2), (-1, -2, 7, 23, 11, -5, -20, 21), (0, 0, 2, -7, -1, 1, 7, -8), (1, 1, 3, 1, 2, 0, -1, -2), (-2, -3, 2, 7, 2, -3, -4, 11), (-1, -1, -5, -14, -9, 2, 14, -8)])
A.characteristic_polynomial().factor()
    </input>
    <output>
        
    </output>
</sage>
<p>
We see that <m>f(x)=(x-2)^4(x+1)^4</m>. This tells us that <m>V=\R^8</m> decomposes into two generalized eigenspaces 
<me>
    V=G(2,T)\oplus G(-1,T)
</me>,
and moreover (looking at the multiplicities), that <me>\dim G(2,T)=\dim G(-1,T)=2</me>. 
</p>
<p>
    Now compute the dot diagram for <m>\lambda=2</m>. Since <m>\dim(2,T)=4</m>, we know that <m>G(2, T)=\NS(T-2I)^4</m>, and thus we only need to look at <m>\dim \NS (T-2I)^i</m> for <m>1\leq i\leq 4</m>. 
</p>
<sage>
    <input>
        N=A-2
        for i in range(1,5):
            print((N^i).nullity())
    </input>
    <output>
    </output>
</sage>
<p>
    Let <m>r_i</m> be the number of dots in the <m>i</m>-th row of our dot diagram for <m>\lambda=2</m>. From the computation above, we see that 
    <md>
        <mrow>r_1 \amp =\dim \NS(A-2I)=3</mrow>
        <mrow>r_2 \amp =\dim \NS(A-2I)^2-\dim \NS(A-2I)=1</mrow>
        <mrow>r_i \amp =\dim \NS(A-2I)^i-\dim\NS(A-2I)^{i-1}=0, i\geq 3</mrow>
    </md>.
    The dot diagram for <m>\lambda=2</m> is thus 
    <me>{\Huge
        \begin{array}{rrr}
        \cdot \amp \cdot \amp \cdot \\
        \cdot \amp \amp 
        \end{array}}
    </me>
    and the Jordan form of <m>T\vert_{G(2, T)}</m> breaks into 3 blocks of size <m>2\times 2</m>, <m>1\times 1</m>, and <m>1\times 1</m>. 
    <me>
        \left[\begin{array}{rr|r|r}
        2\amp 1 \amp 0 \amp 0\\
        0\amp 2\amp 0\amp 0 \\
        \hline
        0\amp 0\amp 2\amp 0 \\
        \hline
        0\amp 0\amp 0\amp 2
        \end{array}
        \right]
    </me>.
</p>
<p>
    Now compute the dot diagram for <m>\lambda=-1</m>.
</p>
<sage>
    <input>
        N=A+1
        for i in range(1,5):
            print((N^i).nullity())
    </input>
    <output>
        
    </output>
</sage>
<p>
    The corresponding dot diagram now consists of a single column
    <me>
        {\Large
        \begin{array}{r}
        \cdot\\
        \cdot\\
        \cdot\\
        \cdot
        \end{array}
        }
    </me>
    and thus the Jordan form for <m>T\vert_{G(-1,T)}</m> consists of a single <m>4\times 4</m> Jordan block
    <me>
        \begin{bmatrix}
        -1\amp 1\amp 0\amp 0\\
        0\amp -1\amp 1\amp 0\\
        0\amp 0\amp -1\amp 1\\
        0\amp 0\amp 0\amp -1
        \end{bmatrix}
    </me>.
    In summary, we conclude that there is a Jordan basis <m>B</m> of the form 
    <me>
        B=B_1*B_2*B_3*B_4
    </me>, 
    where 
    <md>
        <mrow>B_1 \amp =((T-2I)v_1,v_1)</mrow>
        <mrow>B_2 \amp =(v_2)</mrow>
        <mrow>B_2 \amp =(v_3)</mrow>
        <mrow>B_4 \amp =((T+I)^3(v_4),(T+I)^2(v_4),(T+I)(v_4),v_4)</mrow>
    </md>
    for some nonzero vectors <m>v_1,v_2,v_3,v_4</m>, and we have 
    <me>
        [T]_B=\left[\begin{array}{rr|r|r|rrrr}
2 \amp 1 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \\
0 \amp 2 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \\
\hline
 0 \amp 0 \amp 2 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \\
\hline
 0 \amp 0 \amp 0 \amp 2 \amp 0 \amp 0 \amp 0 \amp 0 \\
\hline
 0 \amp 0 \amp 0 \amp 0 \amp -1 \amp 1 \amp 0 \amp 0 \\
0 \amp 0 \amp 0 \amp 0 \amp 0 \amp -1 \amp 1 \amp 0 \\
0 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \amp -1 \amp 1 \\
0 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \amp 0 \amp -1
\end{array}\right]
    </me>.
Let us confirm with Sage.   
</p>
<sage>
    <input>
        show(A.jordan_form())
    </input>
    <output>
        
    </output>
</sage>

</statement>

</example>
<example xml:id="eg_jordan_form">
<title>Computing Jordan form</title>
<statement>
<p>
    Let <m>T=T_A\colon \R^8\rightarrow \R^8</m>, where 
    <me>
        A=\begin{amatrix}[rrrrrrrr]
        -\frac{3}{2} \amp 0 \amp 0 \amp -1 \amp 0 \amp -1 \amp 1 \amp -3 \\
3 \amp \frac{5}{2} \amp -4 \amp 4 \amp -1 \amp -2 \amp 4 \amp 1 \\
-3 \amp -2 \amp \frac{9}{2} \amp -4 \amp 1 \amp 1 \amp -6 \amp -3 \\
-3 \amp -12 \amp 8 \amp -\frac{7}{2} \amp -3 \amp 8 \amp -18 \amp 5 \\
-2 \amp -8 \amp 6 \amp -3 \amp -\frac{3}{2} \amp 6 \amp -12 \amp 4 \\
1 \amp -9 \amp 2 \amp 2 \amp -5 \amp \frac{13}{2} \amp -9 \amp 8 \\
-1 \amp 0 \amp 2 \amp -2 \amp 1 \amp 1 \amp -\frac{1}{2} \amp 0 \\
0 \amp 4 \amp -2 \amp 0 \amp 2 \amp -3 \amp 5 \amp -\frac{5}{2}
        \end{amatrix}
    </me>.
    <ol>
        <li>
            <p>
                Use the SageCells below to compute a Jordan normal form of <m>T</m> in a step-by-step fashion, as in <xref ref="eg_jordan_form_1"/>. Confirm your answer using the <c>jordan_form()</c> command. 
            </p>
            <sage>
                <input>
                    A=matrix([(-3/2, 0, 0, -1, 0, -1, 1, -3), (3, 5/2, -4, 4, -1, -2, 4, 1), (-3, -2, 9/2, -4, 1, 1, -6, -3), (-3, -12, 8, -7/2, -3, 8, -18, 5), (-2, -8, 6, -3, -3/2, 6, -12, 4), (1, -9, 2, 2, -5, 13/2, -9, 8), (-1, 0, 2, -2, 1, 1, -1/2, 0), (0, 4, -2, 0, 2, -3, 5, -5/2)])
                    show(A)
                    # compute the characteristic polynomial of A and factor
                </input>
                <output>
                    
                </output>
            </sage>
            <sage>
                <input>
                    # compute the dot diagrams for each eigenvalue of A
                </input>
                <output>
                    
                </output>
            </sage>
            <sage>
                <input>
                    # Verify your answer with jordan_form()
                </input>
                <output>
                    
                </output>
            </sage>
        </li>
        <li>
            <p>
                Having computed the Jordan normal form for <m>T</m>, hazard a guess as to what happens to <m>T^k</m> as we let <m>k\to \infty</m>. Verify or falsify your guess in the SageCell below. 
            </p>
            <sage>
                <input>
                    # Compute A^k and see what happens as k goes to infty
                    # Tip N(A) gives decimal versions of the entries of a matrix.
                </input>
                <output>
                    
                </output>
            </sage>
        </li>

    </ol>
    
</p>
</statement>

</example>
<p>
    Having successfully computed a few Jordan <em>forms</em> for linear operators, we should point out that we have <em>not</em> yet computed an actual Jordan <em>basis</em>. An algorithm for computing Jordan bases can be extracted from the proof of <xref ref="th_jordan_form"/>, though it requires significantly more computational work. We content ourselves with illustrating the method with a manageable example, done systematically.
</p>
<example xml:id="eg_jordan_basis">
<title>Jordan basis</title>
<statement>
<p>
Let <m>T=T_A\colon \R^6\rightarrow \R^6</m>, where
<me>
    A=\left[\begin{array}{rrrrrr}
2 \amp -1 \amp 1 \amp 2 \amp -1 \amp 2 \\
-3 \amp 3 \amp -4 \amp -8 \amp 10 \amp -14 \\
-2 \amp 1 \amp -1 \amp -7 \amp 8 \amp -12 \\
0 \amp 0 \amp 0 \amp 1 \amp 1 \amp -2 \\
-2 \amp 0 \amp -2 \amp -5 \amp 9 \amp -10 \\
-1 \amp 0 \amp -1 \amp -2 \amp 3 \amp -2
\end{array}\right]
</me>.
Proceeding as in the examples above, we find that the characteristic polynomial of <m>T</m> is <m>f(x)=(x-2)^6</m>, and that a normal form of <m>T</m> is 
<me>
    \left[\begin{array}{rrr|rr|r}
2 \amp 1 \amp 0 \amp 0 \amp 0 \amp 0 \\
0 \amp 2 \amp 1 \amp 0 \amp 0 \amp 0 \\
0 \amp 0 \amp 2 \amp 0 \amp 0 \amp 0 \\
\hline
 0 \amp 0 \amp 0 \amp 2 \amp 1 \amp 0 \\
0 \amp 0 \amp 0 \amp 0 \amp 2 \amp 0 \\
\hline
 0 \amp 0 \amp 0 \amp 0 \amp 0 \amp 2
\end{array}\right]
</me>.
A Jordan basis of <m>T</m> will thus consist of three cycles 
<md>
    <mrow>B_1 \amp =(N^2(v_1),N(v_1),v_1)</mrow>
    <mrow>B_2 \amp =(N(v_2),v_2)</mrow>
    <mrow>B_3 \amp =(v_3)</mrow>
</md>.
It is illuminating to arrange this basis as in our dot diagrams: 
<me>
    \begin{array}{ccc}
    N^2(v_1) \amp N(v_2) \amp v_3\\
    N(v_1) \amp v_2 \amp \\
    v_1 \amp \amp
    \end{array}
</me>
Following the argument in <xref ref="th_jordan_form"/>, we will first compute a Jordan basis for <m>\im N^2</m>, then modify this appropriately to get a Jordan basis of <m>\im N</m>, then repeat the previous step to get a Jordan basis of <m>\im T^0=\R^6</m>.  
</p>
<p>
    From the diagram above, we see that <m>\dim \im N^2=1</m>, and that <m>\im N^2\subseteq \NS N=E(2, T)</m>. Thus any basis of <m>\im N^2=\CS (A-2I)^2</m> will consist of a single eigenvector, and thus will automatically be a Jordan basis. As we see below, we can choose <m>w_1=(1,-1,-1,0,0)</m> for the sole element of this basis.
</p>
<sage>
    <input>
        A=matrix([(2, -1, 1, 2, -1, 2), (-3, 3, -4, -8, 10, -14), (-2, 1, -1, -7, 8, -12), (0, 0, 0, 1, 1, -2), (-2, 0, -2, -5, 9, -10), (-1, 0, -1, -2, 3, -2)])
        N=A-2
        show(N)
        show(N^2)
    </input>
    <output>
        
    </output>
</sage>
<p>
    Following the induction argument in the proof of <xref ref="th_jordan_form"/>, to create a Jordan basis of <m>\im N^2</m>, we (a) lengthen the cycle <m>(w_1)</m> to a cycle <m>(T(u_1), u_1)</m>, where <m>u_1\in \im N</m> and <m>T(u_1)=w_1</m>, (b) extend <m>(w_1)</m> to a basis <m>(w_1,w_2)</m> of <m>\NS T\cap \im N</m>, producing the two cycles of generalized eigenvectors <m>(T(u_1),u_1), (w_2)</m>, which form a basis of <m>\im N</m>. From the computation of <m>N^2</m> above, we see that <m>N^2\bolde_1=w_1</m>. Thus we can pick 
    <me>
        u_1=N\bolde_1=(0,-3,-2,0,-2,-1)
    </me>.
    To extend <m>(w_1)</m> to a basis of <m>\NS N\cap \im N</m>, we first use Sage to compute a basis of this space. 
</p>
<sage>
    <input>
        W1=N.right_kernel()
        W2=N.column_space()
        W=W1.intersection(W2)
        W.basis()
    </input>
    <output>
        
    </output>
</sage>
<p>
    Since <m>\dim \NS N\cap \im N=2</m>, we see that we can add either of the basis elements above to <m>w_1</m> to get a basis. We choose <m>w_2=(1,5,4,1,5,2)</m>. A Jordan basis of <m>\im N</m> is then obtained by concatenating the two cyles of generalized eigenvectors below
    <md>
        <mrow>(N^2\bolde_1,N\bolde_1) \amp = ((1,-1,-1,0,0,0),(0,-3,-2,0,-2,-1)) </mrow>
        <mrow>(w_2) \amp = (1,5,4,1,5,2)</mrow>
    </md>.
    We now repeat this process to transform the Jordan basis of <m>\im N</m> into a Jordan basis of <m>\R^6</m>. First we lengthen the two cycles above. Clearly the first cycle can be lengthened by appending <m>\bolde_1</m>. For the second we find <m>v_2</m> satisfying <m>Nv_2=w_2</m>. As we show below, we can choose <m>v_2=(0,-3,0,-1,0,0)</m>. 
</p>
<sage>
    <input>
        N.solve_right(vector([1,5,4,1,5,2]))
    </input>
    <output>
        
    </output>
</sage>
<p>This yields the two cycles 
    <md>
        <mrow>(N^2\bolde_1, N\bolde_1, \bolde_1) \amp = ((1,-1,-1,0,0,0),(2,-3,-2,0,-2,1),(1,0,0,0,0,0)) </mrow>
        <mrow>(Nv_2,v_2) \amp = ((1,5,4,1,5,2),(0,-3,0,-1,0,0))</mrow>
    </md>.
    Lastly, we extend <m>(N^2\bolde_1, N\boldv_2)</m> to a basis <m>(N^2\bolde_1, N\boldv_2,v_3)</m> of <m>\NS N</m>. This can be done systematically by putting <m>N^2\bolde_1, N\boldv_2</m> in as the first two columns of a matrix, followed by a complete basis for <m>\NS N</m>, and then using the column space algorithm to contract to a basis. The computation below creates this augmented matrix; we see by inspection that we can pick <m>v_3=(1,1,0,1,1,0)</m>.
</p>
<sage>
    <input>
        A1=matrix([[1,-1,-1,0,0,0],[1,5,4,1,5,2]]).transpose()
        A2=N.right_kernel_matrix().transpose()
        A1.augment(A2)
    </input>
    <output>
        
    </output>
</sage>
<p>
    Putting it all together, we obtain the following cycles, whose concatenation is a Jordan basis for <m>T</m>: 
    <md>
        <mrow>(N^2(v_1),N(v_1),v_1)\amp= ((1,-1,-1,0,0,0),(0,-3,-2,0,-2,-1),(1,0,0,0,0,0)) </mrow>
        <mrow>(N(v_2),v_2) \amp= ((1,5,4,1,5,2), (0,-3,0,-1,0,0)) </mrow>
        <mrow> (v_3) \amp=(1,1,0,1,1,0) </mrow>
    </md>
    Time to put our theory to the test. We should obtain the Jordan form of <m>T</m> by the change of basis formula 
    <me>
        P^{-1}AP
    </me>,
    where 
    <me>
        P=\left[\begin{array}{rrrrrr}
1 \amp 0 \amp 1 \amp 1 \amp 0 \amp 1 \\
-1 \amp -3 \amp 0 \amp 5 \amp -3 \amp 1 \\
-1 \amp -2 \amp 0 \amp 4 \amp 0 \amp 0 \\
0 \amp 0 \amp 0 \amp 1 \amp -1 \amp 1 \\
0 \amp -2 \amp 0 \amp 5 \amp 0 \amp 1 \\
0 \amp -1 \amp 0 \amp 2 \amp 0 \amp 0
\end{array}\right]
    </me>
</p>
<sage>
    <input>
        P=matrix([(1, 0, 1, 1, 0, 1),
 (-1, -3, 0, 5, -3, 1),
 (-1, -2, 0, 4, 0, 0),
 (0, 0, 0, 1, -1, 1),
 (0, -2, 0, 5, 0, 1),
 (0, -1, 0, 2, 0, 0)])
 show(P^-1*A*P)
    </input>
    <output>
        
    </output>
</sage>
<p>
    We did it!
</p>
</statement>

</example>

</section>